---
title: "Cluster global bird population based on traits"
output: html_notebook
---

Clear workspace
```{r}
rm(list = ls())
```

Unload packages
```{r}
tryCatch({
  invisible(lapply(paste0("package:", names(sessionInfo()$otherPkgs)),   # Unload add-on packages
                 detach,
                 character.only = TRUE, unload = TRUE))
})
```

```{r}
library(tidyverse)
library(densityClust)
library(scales)
library(ggpubr)
```

Pigot et al (2020)
[Macroevolutionary convergence connects morphological form to ecological function in birds]
-------------------------------------------------------------------------------------------

PC1: (83%) primary axis of body size
PC2:  (6%) the spectrum from small to large beaks
PC3:  (4%) species with short tails and pointed beaks (e.g. kiwis) vs those with long tails and stubby beaks
PC4:  (3%) species with long tails and pointed beaks vs those with short tails and stubby beaks

Found that dimensionality varied from the two-dimensional niche of nectarivores to the four-dimensional niche of frugivores, and that niches are on average defined by at least three trait dimensions.
Taking all trophic niches together, an integrated niche space is minimally described by a four-dimensional morphospace

Used Query:
-----------
SELECT 
  scientific_name,
  common_name,
  taxonomic_order,
  taxonomic_family,
  body_morphspace.pc1,
  body_morphspace.pc2,
  body_morphspace.pc3,
  body_morphspace.pc4,
  trophic_niche,
  foraging_niche
FROM `endless-matter-297214.model.taxonomy` 
WHERE scientific_name in (SELECT scientific_name FROM `endless-matter-297214.model.regional_species_filtered`)
 
```{r}
taxonomy <- read_csv("taxonomy.csv")
taxonomy
```

Mouillot et al (2021)
[The dimensionality and structure of species trait spaces]
----------------------------------------------------------
Measure of trait space quality:

(1) being unitless so independent of the number, range or value of traits; 
(2) being standardised between 0 and 1 with a clear and intuitive interpretation of these extreme values;
(3) avoiding the dilemma of whether or not to square the error, which arises in distance- based quality metrics; 
(4) being asymmetric by construction so only considering that the lower dimensional distance matrix is a poorer representation of species distribution in trait space compared with the initial distance matrix;
(5) proposing a common, albeit arbitrary, threshold to define quality.

To cluster species in the trait space and potentially identify unique species, we used the ‘clustering by fast search and find of density peaks’ algorithm, which is based on initial pairwise distances and does not require dimensionality reduction (Rodriguez & Laio, 2014)


```{r}
taxonomy$pc1_scaled <- rescale(taxonomy$pc1, to = c(0, 1), from = range(taxonomy$pc1, na.rm = TRUE, finite = TRUE)) * 0.83
taxonomy$pc2_scaled <- rescale(taxonomy$pc2, to = c(0, 1), from = range(taxonomy$pc2, na.rm = TRUE, finite = TRUE)) * 0.06
taxonomy$pc3_scaled <- rescale(taxonomy$pc3, to = c(0, 1), from = range(taxonomy$pc3, na.rm = TRUE, finite = TRUE)) * 0.04
taxonomy$pc4_scaled <- rescale(taxonomy$pc4, to = c(0, 1), from = range(taxonomy$pc4, na.rm = TRUE, finite = TRUE)) * 0.04
```


```{r}
distribution <- dist(taxonomy[,c("pc1", "pc2", "pc3", "pc4")])
clustered <- densityClust(distribution, gaussian=TRUE)
plot(clustered)
```
RHO - The threshold for local density when detecting cluster peaks
Delta - The threshold for minimum distance to higher density when detecting cluster peaks
```{r}
clusters <- findClusters(clustered, rho=0.2, delta=0.5)
clusters
```


```{r}
taxonomy$cluster <- clusters$clusters
```


```{r}
ggarrange(
  ncol = 2,
  nrow = 2,
  ggplot(taxonomy, aes(x = pc1, y = pc3, colour = as.factor(cluster))) + geom_point(alpha = 0.2) + theme_bw() +  theme(legend.position="none", axis.title.x=element_blank()) + ylab("ST + PB -> LT + SB"),
  ggplot(taxonomy, aes(x = pc2, y = pc3, colour = as.factor(cluster))) + geom_point(alpha = 0.2) + theme_bw() + theme(legend.position="none", axis.title.x=element_blank(), axis.title.y=element_blank()),
  ggplot(taxonomy, aes(x = pc1, y = pc4, colour = as.factor(cluster))) + geom_point(alpha = 0.2) + theme_bw() + theme(legend.position="none") + ylab("LT + PB -> ST + SB") + xlab("Body Size"),
  ggplot(taxonomy, aes(x = pc2, y = pc4, colour = as.factor(cluster))) + geom_point(alpha = 0.2) + theme_bw() + theme(legend.position="none", axis.title.y=element_blank()) + xlab("Beak Size")
)

```
```{r}
results <- taxonomy[order(taxonomy$cluster, taxonomy$trophic_niche, taxonomy$foraging_niche),c("cluster", "foraging_niche", "trophic_niche", "common_name", "taxonomic_order", "scientific_name")]
results
```

###########################
 Test it out
###########################

```{r}
assign_clusters <- function(species) {
  left_join(species, taxonomy)
}
```

```{r}
london <- read_csv("test_data_london.csv")
london <- assign_clusters(london)
london

nrow(unique(london[,c("cluster")]))
nrow(unique(london[,c("cluster", "trophic_niche", "foraging_niche")]))
```

```{r}
test_locality_species_data <- read_csv('test_data_all_localities.csv')
```

```{r}
london_test_localities <- unique(test_locality_species_data[test_locality_species_data$name == 'London', c("locality_id", "f0_")])
london_test_localities
```

```{r}
locality <- data.frame(test_locality_species_data[test_locality_species_data$locality_id == 'L10042193',])
locality <- assign_clusters(locality)

locality

cluster_scores = nrow(unique(locality[,c("cluster", "trophic_niche", "foraging_niche")])) / nrow(unique(london[,c("cluster", "trophic_niche", "foraging_niche")]))

cluster_scores
```

```{r}
locallity_cluster_scores <- function(test_localities, regional_pool_clusters) {
  test_localities$cluster_score <- 0
  
  for (row in 1:nrow(test_localities)) {
    locality_id <- test_localities[row, "locality_id"]$locality_id
    locality <- data.frame(test_locality_species_data[test_locality_species_data$locality_id == locality_id,])
    locality <- assign_clusters(locality)
    
    test_localities$cluster_score[row] <- nrow(unique(locality[,c("cluster", "trophic_niche", "foraging_niche")])) / nrow(unique(london[,c("cluster", "trophic_niche", "foraging_niche")]))
  }
  
  test_localities
}
```


```{r}
london_scores <- locallity_cluster_scores(london_test_localities, report_clusters(london))
london_scores
```

```{r}
colombo <- read_csv("test_data_colombo.csv")
colombo <- assign_clusters(colombo)
```

```{r}
colombo_test_localities <- unique(test_locality_species_data[test_locality_species_data$name == 'Colombo', c("locality_id", "f0_")])
colombo_scores <- locallity_cluster_scores(colombo_test_localities, report_clusters(colombo))
colombo_scores
```

```{r}
bogota <- read_csv("test_data_bogota.csv")
bogota <- assign_clusters(bogota)
bogota_test_localities <- unique(test_locality_species_data[test_locality_species_data$name == 'Bogota', c("locality_id", "f0_")])
bogota_scores <- locallity_cluster_scores(bogota_test_localities, report_clusters(bogota))
bogota_scores
```

```{r}
bangaluru <- read_csv("test_data_bangaluru.csv")
bangaluru <- assign_clusters(bangaluru)
bangaluru_test_localities <- unique(test_locality_species_data[test_locality_species_data$name == 'Bengaluru', c("locality_id", "f0_")])
bangaluru_scores <- locallity_cluster_scores(bangaluru_test_localities, report_clusters(bangaluru))
bangaluru_scores
```

```{r}
vancouver <- read_csv("test_data_vancouver.csv")
vancouver <- assign_clusters(vancouver)
vancouver_test_localities <- unique(test_locality_species_data[test_locality_species_data$name == 'Vancouver', c("locality_id", "f0_")])
vancouver_scores <- locallity_cluster_scores(vancouver_test_localities, report_clusters(vancouver))
vancouver_scores
```



```{r}
london_scores$city = 'London'
colombo_scores$city = 'Colombo'
bogota_scores$city = 'Bogota'
bangaluru_scores$city = 'Bengaluru'
vancouver_scores$city = 'Vancouver'

localities_merged <- rbind(london_scores, colombo_scores, bogota_scores, bangaluru_scores, vancouver_scores)
localities_merged
```

```{r}
ggplot(localities_merged, aes(x = f0_, y = cluster_score * 100, colour = city)) + 
         geom_point() + xlab("% SPP") + ylab("% clusters")
```


```{r}
write_csv(taxonomy[,c("scientific_name", "cluster")], "result.csv")
```

